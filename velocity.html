<!DOCTYPE html>    
<!--
  (c) 2015 Benjamin Crowell, GPL v3
  Based on sample code by:
    Tom Campbell, http://htmlcheats.com/html/resize-the-html5-canvas-dyamically/
    Eric Drowell, http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
-->
<head>
  <meta charset="utf-8">
  <title>Velocity and acceleration of your mouse</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0px;
      border: 0;
      overflow: hidden; /*  Disable scrollbars */
      display: block;  /* No floating content on sides */
    }
  </style>
</head>
 
<body>
 
  <canvas id='x_canvas' style = 'position: absolute; left: 0px; top: 0px;' ></canvas>
  <canvas id='v_canvas' style = 'position: absolute; left: 0px; top: 50%;' ></canvas>
  
  <script>
    (function() {

      function filled_array(size,fill_value) {
        // http://stackoverflow.com/a/13735425/1142217
        return Array.apply(null, Array(size)).map(Number.prototype.valueOf,fill_value);
      }

      var BUFFER_SIZE = 1000;      
      Graph = function(canvas_id) {
        this.canvas_id = canvas_id;
        // circular buffer
        this.buffer_size = BUFFER_SIZE;
        this.data = filled_array(this.buffer_size,0); 
        this.last_valid_time = -1; // no valid data yet
        this.next_time = 0;
        this.canvas = document.getElementById(canvas_id);
        this.context = this.canvas.getContext('2d');
        this.canvas_w = this.context.canvas.width;
        this.canvas_h = this.context.canvas.height;
        this.new_data_point = function (d) {
          this.data[this.next_time] = d;
          if (this.last_valid_time<this.next_time) {this.last_valid_time=this.next_time;}
          this.next_time++;
          if (this.next_time>this.buffer_size-1) {
            this.next_time=0;
            this.last_valid_time = -1;
            redraw(this,true);
          }
          else {
            redraw(this,false);
          }
        };
      };
      var position = new Graph('x_canvas');
      var velocity = new Graph('v_canvas');

      var TIME_INTERVAL = 10; // milliseconds

      var current_mouse_y = 0; // expressed such that 0.0=top of window, 1.0=bottom
      var t = 0;

      function initialize() {
        window.addEventListener('resize',handle_resize_canvas,false);
        handle_resize_canvas(); // Draw canvas border for the first time.
        position.canvas.addEventListener('mousemove',handle_mouse_move,false);
        setInterval(handle_interval_timer,TIME_INTERVAL);
      }

      initialize();

      function handle_interval_timer() {
        t = t + TIME_INTERVAL;
        var previous_time = position.next_time-1;
        if (previous_time == -1) {previous_time=position.buffer_size-1;}
        var previous_y = position.data[previous_time];
        position.new_data_point(current_mouse_y);
        velocity.new_data_point(current_mouse_y-previous_y);
      }
        
      function redraw(graph,is_from_scratch) {
        graph.canvas_w = graph.context.canvas.width;
        graph.canvas_h = graph.context.canvas.height;

        if (is_from_scratch) {
          graph.context.clearRect(0, 0, graph.canvas_w, graph.canvas_h);
          graph.context.beginPath();
        }
        var cx = graph.canvas_w/2;
        var cy = graph.canvas_h/2;
        var x_scale = graph.canvas_w/BUFFER_SIZE;
        var y_scale = graph.canvas_h;
        var i;
        var start_at = graph.last_valid_time;
        if (is_from_scratch) {start_at=1;}
        for (i=start_at; i<=graph.last_valid_time; i++) {
          var x = i*x_scale;
          var y1 = graph.data[i-1];
          var y2 = graph.data[i];
          graph.context.moveTo(x,y1*y_scale);
          graph.context.lineTo(x+x_scale,y2*y_scale);
          graph.context.stroke();
        }
      }
    
      function handle_resize_canvas() {
        position.canvas.width = window.innerWidth;
        position.canvas.height = window.innerHeight/2;
        velocity.canvas.width = window.innerWidth;
        velocity.canvas.height = window.innerHeight/2;
        redraw(position,true);
        redraw(velocity,true);
      }

      function get_mouse_position(canvas, event) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: event.clientX - rect.left,
          y: event.clientY - rect.top
        };
      }

      function handle_mouse_move(event) {
        var mouse_position = get_mouse_position(position.canvas, event);
        current_mouse_y = mouse_position.y/position.canvas_h;
        // console.log("x="+x+", y="+y);
      }

    
    })();
  </script>

</body>
 
</html>
